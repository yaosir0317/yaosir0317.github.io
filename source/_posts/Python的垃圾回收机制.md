---
title: Python的垃圾回收机制
date: 2019-01-14 20:06:56
tags: Python
categories: Python
---

# 内存

计算机中(程序中)直接使用的数据保存在计算机的内存存储器(简称内存).内存是CPU可以直接访问的数据存储设备.与之相应的是外存储器,简称外存,如磁盘,光盘,磁带等.保存在外村里的数据必须先装入内存,而后CPU才能使用它们.

<!--more-->

# 垃圾回收

由上文可知,对内存的管理十分重要,现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。python采用的是`引用计数`机制为主，`标记-清除`和`分代回收`两种机制为辅的策略

## 引用计数

Python中的`ob_refcnt`就是做为引用计数的。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少,当引用计数为0时，该对象生命就结束了。

### 增加计数

- 对象被创建，例如`a="yao"`
- 对象被引用，例如`b=a`
- 对象被作为参数，传入到一个函数中，例如`func(a)`
- 对象作为一个元素，存储在容器中，例如`list1=[a,b]`

### 减少计数

- 对象的别名被显式销毁，例如`del a`
- 对象的别名被赋予新的对象，例如`a=24`
- 一个对象离开它的作用域，例如func函数执行完毕时，func函数中的局部变量（全局变量不会）
- 对象所在的容器被销毁，或从容器中删除对象

### 查看计数

用`sys.getrefcount(a)`查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1

### 优点：

- 简单
- 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

### 缺点

- 维护引用计数消耗资源

- 循环引用

    例:

    ```python
    list1 = []
    list2 = []
    list1.append(list2)
    list2.append(list1)
    # list1和list2两个对象的引用数都是1。
    # 虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们
    ```

**缺点一是可以接收的,但是循环引用会导致内存泄露,因此python还需其他的垃圾回收机制**

## 标记-清除

`标记-清除`是为了解决容器对象可能产生的`循环引用`的问题,可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。

### 分析

我们必须承认一个事实，如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。我们必须先将循环引用摘掉，那么这两个对象的有效计数就现身了。假设两个对象为A、B，我们从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个对A的引用，同样将A的引用减1，这样，就完成了循环引用对象间环摘除。

但是这样就有一个问题，假设对象A有一个对象引用C，而C没有引用A，如果将C计数引用减1，而最后A并没有被回收，显然，我们错误的将C的引用计数减1，这将导致在未来的某个时刻出现一个对C的悬空引用。这就要求我们必须在A没有被删除的情况下复原C的引用计数，如果采用这样的方案，那么维护引用计数的复杂度将成倍增加。

“标记-清除”采用了更好的做法。

### 原理

- 寻找跟对象（root object）的集合作为垃圾检测动作的起点，`跟对象`就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的

- 从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段

- 当检测阶段结束以后，所有的对象就分成`可达`和`不可达`两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是`链表`将这些集合的对象连接在一起）

我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护

这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。

### 缺点

标记和清除的过程效率不高。

## 分代回收

从前面`标记-清除`这样的垃圾回收机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作。为了提高垃圾收集的效率，采用“空间换时间的策略”。

### 原理

将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。