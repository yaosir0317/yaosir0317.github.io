<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
      
    
    
      
    
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="docker,">










<meta name="description" content="什么是docker123456Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 使用 Google 公司推出的 Go 语言 进行开发实现。docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行">
<meta name="keywords" content="docker">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是docker">
<meta property="og:url" content="https://yaosir0317.github.io/2019/03/30/什么是docker/index.html">
<meta property="og:site_name" content="YaoSir">
<meta property="og:description" content="什么是docker123456Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 使用 Google 公司推出的 Go 语言 进行开发实现。docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/1.png">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/2.png">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/3.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1132884/201812/1132884-20181209143400671-1287929772.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1132884/201812/1132884-20181209143438897-152229468.png">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/4.png">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/5.png">
<meta property="og:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/6.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180816115230679-531746266.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180816164829039-1757764520.png">
<meta property="og:updated_time" content="2019-03-30T08:29:59.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="什么是docker">
<meta name="twitter:description" content="什么是docker123456Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 使用 Google 公司推出的 Go 语言 进行开发实现。docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行">
<meta name="twitter:image" content="https://yaosir0317.github.io/2019/03/30/什么是docker/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yaosir0317.github.io/2019/03/30/什么是docker/">





  <title>什么是docker | YaoSir</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YaoSir</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The philosophers have only interpreted the world in various ways - the point however is to change it.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yaosir0317.github.io/2019/03/30/什么是docker/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yaosir0317">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YaoSir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">什么是docker</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-30T15:59:18+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</span><br><span class="line">Docker 使用 Google 公司推出的 Go 语言 进行开发实现。</span><br><span class="line">docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行的Linux容器解决方案。</span><br><span class="line">docker的接口相当简单，用户可以方便的创建、销毁容器。</span><br><span class="line">docker将应用程序与程序的依赖，打包在一个文件里面。运行这个文件就会生成一个虚拟容器。</span><br><span class="line">程序运行在虚拟容器里，如同在真实物理机上运行一样，有了docker，就不用担心环境问题了。</span><br></pre></td></tr></table></figure>
<h3 id="docker应用场景"><a href="#docker应用场景" class="headerlink" title="docker应用场景"></a>docker应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web应用的自动化打包和发布</span><br><span class="line">自动化测试和持续集成、发布</span><br><span class="line">在服务型环境中部署和调整数据库或其他应用</span><br></pre></td></tr></table></figure>
<h1 id="为什么要用docker？"><a href="#为什么要用docker？" class="headerlink" title="为什么要用docker？"></a>为什么要用docker？</h1><p>我们先看看很久很久以前，服务器是怎么部署应用的！</p>
<p><img src="/2019/03/30/什么是docker/1.png" alt="img"></p>
<p>由于物理机的诸多问题，后来出现了虚拟机</p>
<p><img src="/2019/03/30/什么是docker/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是虚拟化也是有局限性的，每一个虚拟机都是一个完整的操作系统，要分配系统资源，虚拟机多道一定程度时，操作系统本身资源也就消耗殆尽，或者说必须扩容</span><br></pre></td></tr></table></figure>
<h1 id="docker与虚拟机的区别"><a href="#docker与虚拟机的区别" class="headerlink" title="docker与虚拟机的区别"></a>docker与虚拟机的区别</h1><p><img src="/2019/03/30/什么是docker/3.png" alt="img"></p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="docker-VS-传统虚拟机"><a href="#docker-VS-传统虚拟机" class="headerlink" title="docker  VS 传统虚拟机"></a>docker  VS 传统虚拟机</h1><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<h1 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h1><p>让开发人员最头疼的麻烦事之一就是环境配置了，每台计算机的环境都不相同，应该如何确保自己的程序换一台机器能运行起来呢？</p>
<p>用户必须确保的是：</p>
<ol>
<li>操作系统的相同</li>
<li>各种平台库和组件的安装</li>
<li>例如python依赖包，环境变量等</li>
</ol>
<p>如何一些低版本的依赖模块和当前环境不兼容，那就头疼了。。。。。</p>
<p>如果环境配置这么痛苦的话，换一台机器，就得重新配置一下，那么在安装软件的时候，带着原始环境一模一样的复制过来。</p>
<p><img src="https://img2018.cnblogs.com/blog/1132884/201812/1132884-20181209143400671-1287929772.png" alt="img"></p>
<p><strong>然而，开发和运维之间聊天一般是这样的</strong></p>
<p><strong><img src="https://img2018.cnblogs.com/blog/1132884/201812/1132884-20181209143438897-152229468.png" alt="img"></strong></p>
<h1 id="解决方案一-虚拟机"><a href="#解决方案一-虚拟机" class="headerlink" title="解决方案一 虚拟机"></a>解决方案一 虚拟机</h1><p> 虚拟机也可以制作模板，基于模板创建虚拟机，保证环境问题一致</p>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<p>（1）资源占用多</p>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<p>（2）冗余步骤多</p>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<p>（3）启动慢</p>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<p><img src="/2019/03/30/什么是docker/4.png" alt="img"></p>
<h1 id="解决方案二-Linux容器"><a href="#解决方案二-Linux容器" class="headerlink" title="解决方案二  Linux容器"></a>解决方案二  Linux容器</h1><p><strong>现在:自从用上docker容器后，可以实现开发、测试和生产环境的统一化和标准化。</strong></p>
<p><strong>镜像作为标准的交付件，可在开发、测试和生产环境上以容器来运行，最终实现三套环境上的应用以及运行所依赖内容的完全一致。</strong></p>
<p> 由于虚拟机的诸多问题，Linux发展出了另一种虚拟化技术：Linux容器（Linux Containers，缩写LXC）</p>
<p><strong>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。在正常进程的外面套了一个保护层，对于容器里面进程来说，它接触的资源都是虚拟的，从而实现和底层系统的隔离。</strong></p>
<p>（1）启动快</p>
<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<p>（2）资源占用少</p>
<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<p>（3）体积小</p>
<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<p><img src="/2019/03/30/什么是docker/5.png" alt="img"></p>
<h1 id="docker容器的优势"><a href="#docker容器的优势" class="headerlink" title="docker容器的优势"></a>docker容器的优势</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">更高效的利用系统资源</span><br><span class="line">由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统 资源的利用率更高。</span><br><span class="line">无论是应用执行速度、内存损耗或者文件存储速度，都要比传 统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运 行更多数量的应用。</span><br><span class="line">更快速的启动时间</span><br><span class="line">传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接 运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。</span><br><span class="line">一致的运行环境</span><br><span class="line">开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环 境不一致，导致有些 bug 并未在开发过程中被发现。</span><br><span class="line">而 Docker 的镜像提供了除内 核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">持续交付和部署</span><br><span class="line">对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意 地方正常运行。</span><br><span class="line">使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员 可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系 统进行集成测试，</span><br><span class="line">而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</span><br><span class="line">而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环 境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更轻松的迁移</span><br><span class="line">由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在 很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运 行结果是一致的。</span><br><span class="line">因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一 个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</span><br></pre></td></tr></table></figure>
<h1 id="工作中的虚拟化和容器"><a href="#工作中的虚拟化和容器" class="headerlink" title="工作中的虚拟化和容器"></a>工作中的虚拟化和容器</h1><p><img src="/2019/03/30/什么是docker/6.png" alt="img"></p>
<h1 id="docker三大概念"><a href="#docker三大概念" class="headerlink" title="docker三大概念"></a>docker三大概念</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器三大基本概念</span><br><span class="line">镜像 image</span><br><span class="line">容器 container</span><br><span class="line">仓库 repository</span><br><span class="line">docker整个生命周期就是这三个概念。</span><br></pre></td></tr></table></figure>
<p>docker镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Docker镜像就是一个只读的模板。</span><br><span class="line"></span><br><span class="line">例如：一个镜像可以包含一个完整的CentOS操作系统环境，里面仅安装了Apache或用户需要的其他应用程序。</span><br><span class="line"></span><br><span class="line">镜像可以用来创建Docker容器。</span><br><span class="line"></span><br><span class="line">Docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</span><br></pre></td></tr></table></figure>
<p>image的分层存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为镜像包含完整的root文件系统，体积是非常庞大的，因此docker在设计时按照Union FS的技术，将其设计为分层存储的架构。</span><br><span class="line">镜像不是ISO那种完整的打包文件，镜像只是一个虚拟的概念，他不是一个完整的文件，而是由一组文件组成，或者多组文件系统联合组成。</span><br></pre></td></tr></table></figure>
<p>docker容器(container)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">image和container的关系，就像面向对象程序设计中的 类和实例一样，镜像是静态的定义（class），容器是镜像运行时的实体（object）。</span><br><span class="line">容器可以被创建、启动、停止、删除、暂停</span><br><span class="line">Docker利用容器来运行应用。</span><br><span class="line"></span><br><span class="line">容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。</span><br><span class="line"></span><br><span class="line">可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</span><br><span class="line"></span><br><span class="line">注意：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</span><br></pre></td></tr></table></figure>
<p>docker仓库(repository)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">仓库是集中存放镜像文件的场所。有时候把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)。</span><br><span class="line"></span><br><span class="line">仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</span><br><span class="line"></span><br><span class="line">最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括Docker Pool等，可以提供大陆用户更稳定快读的访问。</span><br><span class="line"></span><br><span class="line">当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下载在另外一台机器上使用这个镜像时候，只需需要从仓库上pull下来就可以了。</span><br><span class="line"></span><br><span class="line">注意：Docker仓库的概念跟Git类似，注册服务器可以理解为GitHub这样的托管服务。</span><br></pre></td></tr></table></figure>
<h1 id="docker-Registry"><a href="#docker-Registry" class="headerlink" title="docker Registry"></a>docker Registry</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服 务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务 供用户管理私有镜像。</span><br><span class="line"></span><br><span class="line">最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并 拥有大量的高质量的官方镜像。</span><br><span class="line"></span><br><span class="line">除此以外，还有 CoreOS 的 Quay.io，CoreOS 相 关的镜像存储在这里;Google 的 Google Container Registry，Kubernetes 的镜像 使用的就是这个服务。</span><br><span class="line">由于某些原因，在国内访问这些服务可能会比较慢。</span><br><span class="line">国内的一些云服务商提供了针 对 Docker Hub 的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见 的有 阿里云加速器、DaoCloud 加速器、灵雀云加速器等。</span><br><span class="line">使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从官方网站下载速度会提高很多。在后 面的章节中会有进一步如何配置加速器的讲解。</span><br><span class="line">国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓 库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。</span><br></pre></td></tr></table></figure>
<h1 id="CentOS安装docker"><a href="#CentOS安装docker" class="headerlink" title="CentOS安装docker"></a>CentOS安装docker</h1><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script" target="_blank" rel="noopener">请遵循官方安装方式！！！</a></p>
<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script</a></p>
<p>官方教程如下，最正确安装docker姿势</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>卸载旧版本</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>设置存储库</span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>安装docker社区版</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"><span class="number">4.</span>启动关闭docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>docker版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。</span><br><span class="line">企业版包含了一些收费服务，个人开发者一般用不到。本文的介绍都针对社区版。</span><br></pre></td></tr></table></figure>
<p> 系统环境准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker最低支持centos7且在<span class="number">64</span>位平台上，内核版本在<span class="number">3.10</span>以上[root@python ~ <span class="number">10</span>:<span class="number">48</span>:<span class="number">11</span>]<span class="comment">#uname -r</span></span><br><span class="line"><span class="number">3.10</span><span class="number">.0</span><span class="number">-693.</span>el7.x86_64</span><br></pre></td></tr></table></figure>
<h1 id="Docker镜像加速器"><a href="#Docker镜像加速器" class="headerlink" title="Docker镜像加速器"></a>Docker镜像加速器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.daocloud.io/mirror<span class="comment">#accelerator-doc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一条命令加速</span></span><br><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://<span class="number">95822026.</span>m.daocloud.io</span><br></pre></td></tr></table></figure>
<h1 id="docker基础命令注释"><a href="#docker基础命令注释" class="headerlink" title="docker基础命令注释"></a>docker基础命令注释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker --help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">docker [OPTIONS] COMMAND [arg...]</span><br><span class="line"></span><br><span class="line">       docker daemon [ --help | ... ]</span><br><span class="line"></span><br><span class="line">       docker [ --help | -v | --version ]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">self-sufficient runtime <span class="keyword">for</span> containers.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  --config=~/.docker              Location of client config files  <span class="comment">#客户端配置文件的位置</span></span><br><span class="line"></span><br><span class="line">  -D, --debug=false               Enable debug mode  <span class="comment">#启用Debug调试模式</span></span><br><span class="line"></span><br><span class="line">  -H, --host=[]                   Daemon socket(s) to connect to  <span class="comment">#守护进程的套接字（Socket）连接</span></span><br><span class="line"></span><br><span class="line">  -h, --help=false                Print usage  <span class="comment">#打印使用</span></span><br><span class="line"></span><br><span class="line">  -l, --log-level=info            Set the logging level  <span class="comment">#设置日志级别</span></span><br><span class="line"></span><br><span class="line">  --tls=false                     Use TLS; implied by--tlsverify  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  <span class="comment">#信任证书签名CA</span></span><br><span class="line"></span><br><span class="line">  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  <span class="comment">#TLS证书文件路径</span></span><br><span class="line"></span><br><span class="line">  --tlskey=~/.docker/key.pem      Path to TLS key file  <span class="comment">#TLS密钥文件路径</span></span><br><span class="line"></span><br><span class="line">  --tlsverify=false               Use TLS <span class="keyword">and</span> verify the remote  <span class="comment">#使用TLS验证远程</span></span><br><span class="line"></span><br><span class="line">  -v, --version=false             Print version information <span class="keyword">and</span> quit  <span class="comment">#打印版本信息并退出</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">    attach    Attach to a running container  <span class="comment">#当前shell下attach连接指定运行镜像</span></span><br><span class="line"></span><br><span class="line">    build     Build an image <span class="keyword">from</span> a Dockerfile  <span class="comment">#通过Dockerfile定制镜像</span></span><br><span class="line"></span><br><span class="line">    commit    Create a new image <span class="keyword">from</span> a containe<span class="string">r's changes  #提交当前容器为新的镜像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cp    Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    create    Create a new container  #创建一个新的容器，同run 但不启动容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    diff    Inspect changes on a container'</span>s filesystem  <span class="comment">#查看docker容器变化</span></span><br><span class="line"></span><br><span class="line">    events    Get real time events <span class="keyword">from</span> the server<span class="comment">#从docker服务获取容器实时事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">exec</span>    Run a command <span class="keyword">in</span> a running container<span class="comment">#在已存在的容器上运行命令</span></span><br><span class="line"></span><br><span class="line">    export    Export a containe<span class="string">r's filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    history    Show the history of an image  #展示一个镜像形成历史</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    images    List images  #列出系统当前镜像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    info    Display system-wide information  #显示系统相关信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    inspect    Return low-level information on a container or image  #查看容器详细信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    kill    Kill a running container  #kill指定docker容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    load    Load an image from a tar archive or STDIN  #从一个tar包中加载一个镜像(对应save)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    login    Register or log in to a Docker registry#注册或者登陆一个docker源服务器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    logout    Log out from a Docker registry  #从当前Docker registry退出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    logs    Fetch the logs of a container  #输出当前容器日志信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pause    Pause all processes within a container#暂停容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    port    List port mappings or a specific mapping for the CONTAINER  #查看映射端口对应的容器内部源端口</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ps    List containers  #列出容器列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pull    Pull an image or a repository from a registry  #从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push    Push an image or a repository to a registry  #推送指定镜像或者库镜像至docker源服务器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rename    Rename a container  #重命名容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    restart    Restart a running container  #重启运行的容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rm    Remove one or more containers  #移除一个或者多个容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rmi    Remove one or more images  #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    run    Run a command in a new container  #创建一个新的容器并运行一个命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    save    Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    search    Search the Docker Hub for images  #在docker</span></span><br><span class="line"><span class="string">hub中搜索镜像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    start    Start one or more stopped containers#启动容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    stats    Display a live stream of container(s) resource usage statistics  #统计容器使用资源</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    stop    Stop a running container  #停止容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    tag         Tag an image into a repository  #给源中镜像打标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    top       Display the running processes of a container #查看容器中运行的进程信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    unpause    Unpause all processes within a container  #取消暂停容器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    version    Show the Docker version information#查看容器版本号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    wait         Block until a container stops, then print its exit code  #截取容器停止时的退出状态值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run '</span>docker COMMAND --help<span class="string">' for more information on a command.  #运行docker命令在帮助可以获取更多信息</span></span><br></pre></td></tr></table></figure>
<h1 id="使用docker镜像"><a href="#使用docker镜像" class="headerlink" title="使用docker镜像"></a>使用docker镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从仓库获取镜像</span><br><span class="line">管理本地主机的镜像</span><br></pre></td></tr></table></figure>
<p>获取镜像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从docker registry获取镜像的命令是docker pull。命令格式是：</span><br><span class="line">docker pull [选项][docker registry地址] 仓库名:标签</span><br><span class="line">docker register地址：地址的格式一般是 域名:端口，默认地址是docker hub</span><br><span class="line">仓库名：仓库名是两段格式，用户名/软件名，如果不写用户，默认docker hub用户名是library，也就是官方镜像</span><br></pre></td></tr></table></figure>
<p>镜像文件</p>
<p>docker是把应用程序和其依赖打包在image文件里面，只有通过这个镜像文件才能生成docker容器。<br>一个image文件可以生成多个容器实例。<br>image文件是通用，可以共享的，为了节省时间，我们尽量列出服务器所有镜像文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有的image文件</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="comment">#删除image文件</span></span><br><span class="line">docker image rm [imagename]</span><br></pre></td></tr></table></figure>
<h1 id="搜索docker镜像"><a href="#搜索docker镜像" class="headerlink" title="搜索docker镜像"></a>搜索docker镜像</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker search centos  #搜索所有centos的docker镜像</span></span><br><span class="line"></span><br><span class="line">INDEX                NAME(名称)                  DESCRIPTION(描述)                    STARS(下载次数)OFFICIAL(官方)        AUTOMATED(自动化)</span><br><span class="line"></span><br><span class="line">docker.io           docker.io/centos         The official build of CentOS.        <span class="number">1781</span>               [OK]</span><br><span class="line"></span><br><span class="line">docker.io   docker.io/jdeathe/centos-ssh     CentOS<span class="number">-6</span> <span class="number">6.7</span> x86_64 /             <span class="number">14</span>                                               [OK]</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h1 id="获取docker镜像"><a href="#获取docker镜像" class="headerlink" title="获取docker镜像"></a>获取docker镜像</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以使用docker pull命令来从仓库获取所需要的镜像。下面的例子将从Docker Hub仓库下载一个Centos操作系统的镜像。</span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker pull centos  #获取centos镜像</span></span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker run -it centos /bin/bash  #完成后可以使用该镜像创建一个容器</span></span><br></pre></td></tr></table></figure>
<h1 id="查看docker镜像"><a href="#查看docker镜像" class="headerlink" title="查看docker镜像"></a>查看docker镜像</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">镜像的ID唯一标识了镜像，如果ID相同,说明是同一镜像。</span><br><span class="line"></span><br><span class="line">TAG信息来区分不同发行版本，如果不指定具体标记,默认使用latest标记信息。</span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker images  #查看docker镜像</span></span><br><span class="line"></span><br><span class="line">REPOSITORY(来自那个仓库)       TAG(标签)            IMAGE ID(唯一ID)         CREATED(创建时间)         VIRTUAL SIZE(大小)</span><br><span class="line"></span><br><span class="line">docker.io/centos                   latest              <span class="number">60e65</span>a8e4030           <span class="number">5</span></span><br><span class="line">days ago              <span class="number">196.6</span> MB</span><br><span class="line"></span><br><span class="line">docker.io/nginx             latest              <span class="number">813e3731</span>b203             <span class="number">13</span></span><br><span class="line">days ago             <span class="number">133.8</span> MB</span><br></pre></td></tr></table></figure>
<h1 id="删除Docker镜像"><a href="#删除Docker镜像" class="headerlink" title="删除Docker镜像"></a>删除Docker镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果要移除本地的镜像,可以使用docker rmi命令(在删除镜像之前先用docker rm删除依赖于这个镜像的所有容器)。注意docker rm 命令是移除容器。</span><br><span class="line"></span><br><span class="line">[root@docker ~]# docker rmi imageID  #删除docker镜像</span><br></pre></td></tr></table></figure>
<h1 id="导出docker镜像"><a href="#导出docker镜像" class="headerlink" title="导出docker镜像"></a>导出docker镜像</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果要导出镜像到本地文件,可以使用docker save命令。</span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker save centos &gt; /opt/centos.tar.gz  #导出docker镜像至本地</span></span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># ll /opt/</span></span><br><span class="line"></span><br><span class="line">-rw-r--r-<span class="number">-.1</span> root root <span class="number">204205056</span> <span class="number">12</span>月 <span class="number">30</span> <span class="number">09</span>:<span class="number">53</span> centos.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="导入docker镜像"><a href="#导入docker镜像" class="headerlink" title="导入docker镜像"></a>导入docker镜像</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以使用docker load从本地文件中导入到本地docker镜像库</span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker load &lt; /opt/centos.tar.gz   #导入本地镜像到docker镜像库</span></span><br><span class="line"></span><br><span class="line">[root@docker~]<span class="comment"># docker images  #查看镜像导入情况</span></span><br><span class="line"></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line"></span><br><span class="line">docker.io/centos     latest              <span class="number">60e65</span>a8e4030        <span class="number">5</span> days ago          <span class="number">196.6</span> MB</span><br></pre></td></tr></table></figure>
<h1 id="启动docker容器的方式"><a href="#启动docker容器的方式" class="headerlink" title="启动docker容器的方式"></a>启动docker容器的方式</h1><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态(stopped)的容器重新启动。</p>
<p>因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h1 id="新建容器并且启动"><a href="#新建容器并且启动" class="headerlink" title="新建容器并且启动"></a>新建容器并且启动</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">所需要的命令主要为docker run</span><br><span class="line"></span><br><span class="line">例如,下面的命令输出一个hehe,之后终止容器。</span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker run centos /bin/echo "hehe"  #这跟在本地直接执行 /bin/echo'hehe' </span></span><br><span class="line"></span><br><span class="line">hehe</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">[root@docker ~]<span class="comment"># docker run --name mydocker -it centos /bin/bash#启动一个bash终端,允许用户进行交互。</span></span><br><span class="line"></span><br><span class="line">[root@<span class="number">1</span>c6c3f38ea07 /]<span class="comment"># pwd</span></span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">[root@<span class="number">1</span>c6c3f38ea07 /]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line">anaconda-post.log  bindev  etc  homelib  lib64  lost+foundmedia  mnt  optproc  root  runsbin  srv  systmp  usr  var</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--name:给容器定义一个名称</span><br><span class="line"></span><br><span class="line">-i:则让容器的标准输入保持打开。</span><br><span class="line"></span><br><span class="line">-t:让Docker分配一个伪终端,并绑定到容器的标准输入上</span><br><span class="line"></span><br><span class="line">/bin/bash:执行一个命令</span><br></pre></td></tr></table></figure>
<p><strong>当利用docker run来创建容器时，Docker在后台运行的标准操作包括</strong></p>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载</p>
<p>利用镜像创建并启动一个容器</p>
<p>分配一个文件系统，并在只读的镜像层外面挂在一层可读写层</p>
<p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p>
<p>从地址池配置一个ip地址给容器</p>
<p>执行用户指定的应用程序</p>
<p>执行完毕后容器被终止</p>
<h1 id="docker与”hello-docker”"><a href="#docker与”hello-docker”" class="headerlink" title="docker与”hello docker”"></a>docker与”hello docker”</h1><p>hello world是程序员启蒙语言，我们通过最简单的image文件“hello-world”，来感受一下docker。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取镜像 hello-world</span></span><br><span class="line">docker pull hello-world</span><br><span class="line"><span class="comment">#检查镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#运行image文件,可用容器id</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment">#检查docker容器进程</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#检查所有运行过的容器</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>运行成功后，可以看到结果</p>
<p><img src="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180816115230679-531746266.png" alt="img"></p>
<p>表示你已经成功运行了容器，hello world运行的容器会在完成后，自动终止</p>
<h1 id="运行一个ubuntu容器"><a href="#运行一个ubuntu容器" class="headerlink" title="运行一个ubuntu容器"></a>运行一个ubuntu容器</h1><p>咱们要在cenots7操作系统下，以docker下载一个ubuntu image文件，然后以image启动容器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">11</span>:<span class="number">52</span>:<span class="number">22</span>]<span class="comment">#docker pull ubuntu:14.04</span></span><br><span class="line"><span class="comment">#如图，乌班图的镜像下载，是下载每一层的文件</span></span><br><span class="line">Trying to pull repository docker.io/library/ubuntu ... </span><br><span class="line"><span class="number">14.04</span>: Pulling <span class="keyword">from</span> docker.io/library/ubuntu</span><br><span class="line"><span class="number">8284e13</span>a281d: Pull complete </span><br><span class="line"><span class="number">26e1916</span>a9297: Pull complete </span><br><span class="line"><span class="number">4102</span>fc66d4ab: Pull complete </span><br><span class="line"><span class="number">1</span>cf2b01777b2: Pull complete </span><br><span class="line"><span class="number">7</span>f7a2d5e04ed: Pull complete </span><br><span class="line">Digest: sha256:<span class="number">4851</span>d1986c90c60f3b19009824c417c4a0426e9cf38ecfeb28598457cefe3f56</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure>
<p>下载过程可以看出镜像是由多层存储构成的。下载也是一层一层，并非单一的文件。<br>下载过程中给出每一层的前12位ID。下载结束后会给出sha246的文件一致性校验值。</p>
<h2 id="运行这个乌班图容器！"><a href="#运行这个乌班图容器！" class="headerlink" title="运行这个乌班图容器！"></a>运行这个乌班图容器！</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">12</span>:<span class="number">18</span>:<span class="number">53</span>]<span class="comment">#docker run -it --rm ubuntu:14.04 bash</span></span><br><span class="line"><span class="comment">#此时会进入交互式的shell界面，即可以使用乌班图操作系统</span></span><br><span class="line">root@<span class="number">3</span>efbb2749d7c:/<span class="comment"># cat /etc/os-release  </span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"14.04.5 LTS, Trusty Tahr"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 14.04.5 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"14.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line"><span class="comment">#使用exit退出容器</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run就是运行容器的命令。</span><br><span class="line">参数</span><br><span class="line"> -it ： -i 是交互式操作，-t是终端</span><br><span class="line"> -rm  :   容器退出后将其删除。也可以不指定参数，手动docker rm，使用-rm可以避免浪费空间。</span><br><span class="line"> ubuntu:<span class="number">14.04</span>   这指的是镜像文件</span><br><span class="line"> bash   :  指定用交互式的shell，因此需要bash命令</span><br></pre></td></tr></table></figure>
<h1 id="Docker与CentOS"><a href="#Docker与CentOS" class="headerlink" title="Docker与CentOS"></a>Docker与CentOS</h1><p>docker允许在容器内运行应用程序，使用docker run命令来在容器内运行应用程序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加速docker镜像下载</span></span><br><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://<span class="number">95822026.</span>m.daocloud.io</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">15</span>:<span class="number">14</span>:<span class="number">31</span>]<span class="comment">#docker pull docker.io/centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io/library/centos ...</span><br><span class="line">latest: Pulling <span class="keyword">from</span> docker.io/library/centos</span><br><span class="line"><span class="number">256</span>b176beaff: Pull complete</span><br><span class="line">Digest: sha256:fc2476ccae2a5186313f2d1dadb4a969d6d2d4c6b23fa98b6c7b0a1faad67685</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/centos:latest</span><br></pre></td></tr></table></figure>
<p>运行一个交互式的容器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">15</span>:<span class="number">15</span>:<span class="number">07</span>]<span class="comment">#docker run -it centos /bin/bash</span></span><br><span class="line"><span class="comment">#此时进入docker容器</span></span><br><span class="line">[root@c72e9c40cfe2 /]<span class="comment"># cat /etc/redhat-release</span></span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><strong>-t:</strong>在新容器内指定一个伪终端或终端。</li>
<li><strong>-i:</strong>允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此时就进入了centos系统</span><br><span class="line">可以查看系统相关信息,内核版本信息</span><br><span class="line">cat /proc/version</span><br><span class="line">ls /</span><br></pre></td></tr></table></figure>
<p>此时想要退出容器，使用exit命令</p>
<h1 id="后台模式启动docker"><a href="#后台模式启动docker" class="headerlink" title="后台模式启动docker"></a>后台模式启动docker</h1><p>-d参数：后台运行容器，返回容器ID</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">15</span>:<span class="number">58</span>:<span class="number">14</span>]<span class="comment">#docker run -d centos /bin/sh -c "while true;do echo hello centos; sleep 1;done"</span></span><br><span class="line">c0283f1077d16a2bf2597e269d51a02815334f7390f18a62ed7a4ba07f351b65</span><br><span class="line"><span class="comment">#检查容器进程</span></span><br><span class="line">[root@python ~ <span class="number">15</span>:<span class="number">58</span>:<span class="number">22</span>]<span class="comment">#docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">c0283f1077d1        centos              <span class="string">"/bin/sh -c 'while..."</span>   <span class="number">6</span> seconds ago       Up <span class="number">5</span> seconds                            fervent_turing</span><br><span class="line">[root@oldboy_python ~ <span class="number">15</span>:<span class="number">58</span>:<span class="number">28</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>查看容器内的标准输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs c02</span><br></pre></td></tr></table></figure>
<p>停止容器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop c02</span><br><span class="line"><span class="comment">#此时容器进程不存在</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>启动容器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker start c02</span><br><span class="line"><span class="comment">#检查容器进程</span></span><br><span class="line">docker ps</span><br><span class="line">删除容器</span><br><span class="line">docker rm c02</span><br></pre></td></tr></table></figure>
<p>Docker镜像常用命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images <span class="comment">#列出所有本级镜像</span></span><br><span class="line">docker pull centos <span class="comment">#获取新的centos镜像</span></span><br><span class="line">docker search nginx <span class="comment">#搜索nginx镜像</span></span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过commit修改镜像</span><br><span class="line"><span class="number">2.</span>编写dockerfile</span><br></pre></td></tr></table></figure>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>使用-d参数时，容器启动后会进入后台。某些时候需要进入容器进行操作,有很多种方法，包括使用docker attach命令或nsenter工具等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker  <span class="keyword">exec</span> -it 容器id</span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>
<h1 id="提交创建自定义的镜像-docker-container-commit"><a href="#提交创建自定义的镜像-docker-container-commit" class="headerlink" title="提交创建自定义的镜像(docker container commit)"></a>提交创建自定义的镜像(docker container commit)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>我们进入交互式的centos容器中，发现没有vim命令</span><br><span class="line">docker run -it centos</span><br><span class="line"><span class="number">2.</span>在当前容器中，安装一个vim</span><br><span class="line">yum install -y vim</span><br><span class="line"><span class="number">3.</span>安装好vim之后，exit退出容器</span><br><span class="line">exit</span><br><span class="line"><span class="number">4.</span>查看刚才安装好vim的容器记录</span><br><span class="line">docker container ls -a</span><br><span class="line"><span class="number">5.</span>提交这个容器，创建新的image</span><br><span class="line">docker commit <span class="number">059</span>fdea031ba chaoyu/centos-vim</span><br><span class="line"><span class="number">6.</span>查看镜像文件</span><br><span class="line">[root@master /home]docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">chaoyu/centos-vim   latest              fd2685ae25fe        <span class="number">5</span> minutes ago       <span class="number">348</span>MB</span><br></pre></td></tr></table></figure>
<h1 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h1><p>容器中可以运行网络应用，但是要让外部也可以访问这些应用，可以通过-p或-P参数指定端口映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-P 参数会随机映射端口到容器开放的网络端口</span><br><span class="line">[root@python ~ 16:31:37]#docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>检查映射的端口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#宿主机ip:32768 映射容器的5000端口</span></span><br><span class="line">[root@python ~ <span class="number">16</span>:<span class="number">34</span>:<span class="number">02</span>]<span class="comment">#docker ps -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">cfd632821d7a        training/webapp     "python app.py"     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;5000/tcp   brave_fermi</span><br></pre></td></tr></table></figure>
<p>查看容器日志信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不间断显示log</span></span><br><span class="line">docker logs -f cfd</span><br></pre></td></tr></table></figure>
<p>也可以通过-p参数指定映射端口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定服务器的9000端口，映射到容器内的5000端口</span></span><br><span class="line">[root@python ~ <span class="number">16</span>:<span class="number">46</span>:<span class="number">13</span>]<span class="comment">#docker run -d -p 9000:5000 training/webapp python app.py</span></span><br><span class="line">c0b5a6278d0f4f2e9b9eba8680451111d8b911b61de0c37ea64cb337aefb854e</span><br></pre></td></tr></table></figure>
<p>访问服务器的9000端口</p>
<p>(如果访问失败的话，检查自己的防火墙，以及云服务器的安全组)</p>
<p><img src="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180816164829039-1757764520.png" alt="img"></p>
<h3 id="查看指定容器的端口映射"><a href="#查看指定容器的端口映射" class="headerlink" title="查看指定容器的端口映射"></a>查看指定容器的端口映射</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">16</span>:<span class="number">49</span>:<span class="number">01</span>]<span class="comment">#docker port c0b</span></span><br><span class="line">5000/tcp -&gt; 0.0.0.0:9000</span><br></pre></td></tr></table></figure>
<p>查看容器内的进程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@python ~ <span class="number">16</span>:<span class="number">49</span>:<span class="number">05</span>]<span class="comment">#docker top c0b</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                3926                3912                0                   16:46               ?                   00:00:00            python app.py</span><br></pre></td></tr></table></figure>
<h1 id="利用dockerfile定制镜像"><a href="#利用dockerfile定制镜像" class="headerlink" title="利用dockerfile定制镜像"></a>利用dockerfile定制镜像</h1><p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。我们之前的例子都是使用来自docker hub的镜像，直接使用这些镜像只能满足一定的需求，当镜像无法满足我们的需求时，就得自定制这些镜像。</p>
<p>镜像的定制就是定制每一层所添加的配置、文件。如果可以吧每一层修改、安装、构建、操作的命令都写入到一个脚本，用脚本来构建、定制镜像，这个脚本就是dockerfile。<br>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令 构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch <span class="comment">#制作base image 基础镜像，尽量使用官方的image作为base image</span></span><br><span class="line">FROM centos <span class="comment">#使用base image</span></span><br><span class="line">FROM ubuntu:<span class="number">14.04</span> <span class="comment">#带有tag的base image</span></span><br><span class="line"></span><br><span class="line">LABEL version=“<span class="number">1.0</span>” <span class="comment">#容器元信息，帮助信息，Metadata，类似于代码注释</span></span><br><span class="line">LABEL maintainer=“yao@<span class="number">163.</span>com<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！</span></span><br><span class="line"><span class="string">RUN yum update &amp;&amp; yum install -y vim \</span></span><br><span class="line"><span class="string">    Python-dev #反斜线换行</span></span><br><span class="line"><span class="string">RUN /bin/bash -c "</span>source $HOME/.bashrc;echo $HOME”</span><br><span class="line"></span><br><span class="line">WORKDIR /root <span class="comment">#相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd</span></span><br><span class="line">WORKDIR /test <span class="comment">#如果没有就自动创建</span></span><br><span class="line">WORKDIR demo <span class="comment">#再进入demo文件夹</span></span><br><span class="line">RUN pwd     <span class="comment">#打印结果应该是/test/demo</span></span><br><span class="line"></span><br><span class="line">ADD <span class="keyword">and</span> COPY </span><br><span class="line">ADD hello /  <span class="comment">#把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录</span></span><br><span class="line">ADD test.tar.gz /  <span class="comment">#添加到根目录并解压</span></span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/  <span class="comment">#进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径</span></span><br><span class="line">COPY hello test/  <span class="comment">#等同于上述ADD效果</span></span><br><span class="line"></span><br><span class="line">ADD与COPY</span><br><span class="line">   - 优先使用COPY命令</span><br><span class="line">    -ADD除了COPY功能还有解压功能</span><br><span class="line">添加远程文件/目录使用curl或wget</span><br><span class="line"></span><br><span class="line">ENV <span class="comment">#环境变量，尽可能使用ENV增加可维护性</span></span><br><span class="line">ENV MYSQL_VERSION <span class="number">5.6</span> <span class="comment">#设置一个mysql常量</span></span><br><span class="line">RUN yum install -y mysql-server=“$&#123;MYSQL_VERSION&#125;” </span><br><span class="line"></span><br><span class="line">------这里需要稍微理解一下了-------中级知识---先不讲</span><br><span class="line"></span><br><span class="line">VOLUME <span class="keyword">and</span> EXPOSE </span><br><span class="line">存储和网络</span><br><span class="line"></span><br><span class="line">RUN <span class="keyword">and</span> CMD <span class="keyword">and</span> ENTRYPOINT</span><br><span class="line">RUN：执行命令并创建新的Image Layer</span><br><span class="line">CMD：设置容器启动后默认执行的命令和参数</span><br><span class="line">ENTRYPOINT：设置容器启动时运行的命令</span><br><span class="line"></span><br><span class="line">Shell格式和Exec格式</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">CMD echo ”hello docker”</span><br><span class="line">ENTRYPOINT echo “hello docker”</span><br><span class="line"></span><br><span class="line">Exec格式</span><br><span class="line">RUN [“apt-get”,”install”,”-y”,”vim”]</span><br><span class="line">CMD [“/bin/echo”,”hello docker”]</span><br><span class="line">ENTRYPOINT [“/bin/echo”,”hello docker”]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过shell格式去运行命令，会读取$name指令，而<span class="keyword">exec</span>格式是仅仅的执行一个命令，而不是shell指令</span><br><span class="line">cat Dockerfile</span><br><span class="line">    FROM centos</span><br><span class="line">    ENV name Docker</span><br><span class="line">    ENTRYPOINT [“/bin/echo”,”hello $name”]<span class="comment">#这个仅仅是执行echo命令，读取不了shell变量</span></span><br><span class="line">    ENTRYPOINT  [“/bin/bash”,”-c”,”echo hello $name<span class="string">"]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD</span></span><br><span class="line"><span class="string">容器启动时默认执行的命令</span></span><br><span class="line"><span class="string">如果docker run指定了其他命令(docker run -it [image] /bin/bash )，CMD命令被忽略</span></span><br><span class="line"><span class="string">如果定义多个CMD，只有最后一个执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ENTRYPOINT</span></span><br><span class="line"><span class="string">让容器以应用程序或服务形式运行</span></span><br><span class="line"><span class="string">不会被忽略，一定会执行</span></span><br><span class="line"><span class="string">最佳实践：写一个shell脚本作为entrypoint</span></span><br><span class="line"><span class="string">COPY docker-entrypoint.sh /usr/local/bin</span></span><br><span class="line"><span class="string">ENTRYPOINT [“docker-entrypoint.sh]</span></span><br><span class="line"><span class="string">EXPOSE 27017</span></span><br><span class="line"><span class="string">CMD [“mongod”]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@master home]# more Dockerfile</span></span><br><span class="line"><span class="string">FROm centos</span></span><br><span class="line"><span class="string">ENV name Docker</span></span><br><span class="line"><span class="string">#CMD ["</span>/bin/bash<span class="string">","</span>-c<span class="string">","</span>echo hello $name<span class="string">"]</span></span><br><span class="line"><span class="string">ENTRYPOINT ["</span>/bin/bash<span class="string">","</span>-c<span class="string">","</span>echo hello $name”]</span><br></pre></td></tr></table></figure>
<h1 id="发布docker-image到仓库"><a href="#发布docker-image到仓库" class="headerlink" title="发布docker image到仓库"></a>发布docker image到仓库</h1><p>第一种，docker hub公有镜像发布</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>docker提供了一个类似于github的仓库dockerhub,</span><br><span class="line">网址https://hub.docker.com/需要注册使用</span><br><span class="line"><span class="number">2.</span>注册docker id后，在linux中登录dockerhub</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line">注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tag</span><br><span class="line">docker tag yao/centos-vim yao/centos-vim</span><br><span class="line">语法是：  docker tag   仓库名   yuchao163/仓库名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>推送docker image到dockerhub</span><br><span class="line">docker push yao/centps-cmd-<span class="keyword">exec</span>:latest</span><br><span class="line"><span class="number">4.</span>在dockerhub中检查镜像</span><br><span class="line">https://hub.docker.com/</span><br><span class="line"><span class="number">5.</span>删除本地镜像，测试下载pull 镜像文件</span><br><span class="line">docker pull yao/centos-entrypoint-<span class="keyword">exec</span></span><br></pre></td></tr></table></figure>
<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>但是这种镜像仓库是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>官方提供的私有仓库docker registry用法</span><br><span class="line">https://yeasy.gitbooks.io/docker_practice/repository/registry.html</span><br><span class="line"><span class="number">2.</span>一条命令下载registry镜像并且启动私有仓库容器</span><br><span class="line">私有仓库会被创建在容器的/var/lib/registry下，因此通过-v参数将镜像文件存储到本地的/opt/data/registry下</span><br><span class="line">端口映射容器中的<span class="number">5000</span>端口到宿主机的<span class="number">5000</span>端口</span><br><span class="line">docker run -d \</span><br><span class="line">    -p <span class="number">5000</span>:<span class="number">5000</span> \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br><span class="line"><span class="number">3.</span>检查启动的registry容器</span><br><span class="line">docker ps</span><br><span class="line"><span class="number">4.</span>测试连接容器</span><br><span class="line">telnet <span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span> <span class="number">5000</span></span><br><span class="line"><span class="number">5.</span>修改镜像tag,以docker registry的地址端口开头</span><br><span class="line">docker tag hello-world:latest <span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span>:<span class="number">5000</span>/hello-world:latest</span><br><span class="line"><span class="number">6.</span>查看docker镜像，找到registry的镜像</span><br><span class="line">docker images</span><br><span class="line"><span class="number">7.</span>Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，这里必须写正确json数据</span><br><span class="line">[root@master /]<span class="comment"># cat /etc/docker/daemon.json</span></span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"http://95822026.m.daocloud.io"</span>],</span><br><span class="line"><span class="string">"insecure-registries"</span>:[<span class="string">"192.168.119.10:5000"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">写入到docker服务中，写入到[Service]配置块中，加载此配置文件</span><br><span class="line">[root@master home]<span class="comment"># grep 'EnvironmentFile=/etc/docker/daemon.json' /lib/systemd/system/docker.service</span></span><br><span class="line">EnvironmentFile=-/etc/docker/daemon.json</span><br><span class="line"><span class="number">8.</span>修改了docker配置文件，重新加载docker</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="number">9.</span>重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="number">10.</span>重启了docker，刚才的registry容器进程挂掉了，因此重新启动它</span><br></pre></td></tr></table></figure>
<p>docker run –privileged=true -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--privileged=true  docker容器的安全机制：设置特权级运行的容器</span><br><span class="line"><span class="number">11.</span>推送本地镜像</span><br><span class="line">docker push <span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span>:<span class="number">5000</span>/hello-world</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span>由于docker registry没有web节目，但是提供了API数据</span><br><span class="line">官网教程：https://docs.docker.com/registry/spec/api/<span class="comment">#listing-repositories</span></span><br><span class="line"></span><br><span class="line">curl http://<span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span>:<span class="number">5000</span>/v2/_catalog</span><br><span class="line"></span><br><span class="line">或者浏览器访问http://<span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span>:<span class="number">5000</span>/v2/_catalog</span><br><span class="line"><span class="number">13.</span>删除本地镜像，从私有仓库中下载</span><br><span class="line">docker pull <span class="number">192.168</span><span class="number">.119</span><span class="number">.10</span>:<span class="number">5000</span>/hello-world</span><br></pre></td></tr></table></figure>
<h1 id="打包flask程序与dockerfile"><a href="#打包flask程序与dockerfile" class="headerlink" title="打包flask程序与dockerfile"></a>打包flask程序与dockerfile</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">确保app.py和dockerfile在同一个目录！</span><br><span class="line">1.准备好app.py的flask程序</span><br><span class="line">[root@master home]# cat app.py</span><br><span class="line">#coding:utf8</span><br><span class="line">from flask import Flask</span><br><span class="line">app=Flask(__name__)</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello docker&quot;</span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;,port=8080)</span><br><span class="line">[root@master home]# ls</span><br><span class="line">app.py  Dockerfile</span><br><span class="line"></span><br><span class="line">2.编写dockerfile</span><br><span class="line">FROM centos</span><br><span class="line">COPY CentOS-Base.repo /etc/yum.repos.d/</span><br><span class="line">COPY epel.repo /etc/yum.repos.d/ </span><br><span class="line">RUN yum clean all </span><br><span class="line">RUN yum install python-setuptools -y</span><br><span class="line">RUN easy_install flask</span><br><span class="line">COPY flask.py /opt/</span><br><span class="line">WORKDIR /opt</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;python&quot;,&quot;flask.py&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>构建镜像image</span><br><span class="line">docker build -t yao/flask-hello-docker .</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查看创建好的images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>启动此flask-hello-docker容器，映射一个端口供外部访问</span><br><span class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> yao/flask-hello-docker</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>检查运行的容器</span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener">
  </a>;)</p>

      
    </div>
    
    
    

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #555;font-size:14px;">-------------The End-------------</div>
    
</div>

	  
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/01/scrapy/" rel="next" title="基于Python的爬虫之二 Scrapy爬虫框架">
                <i class="fa fa-chevron-left"></i> 基于Python的爬虫之二 Scrapy爬虫框架
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>
  



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yaosir0317</p>
              <p class="site-description motion-element" itemprop="description">yaosir0317个人博客,持续更新中...</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yaosir0317" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是docker"><span class="nav-number">1.</span> <span class="nav-text">什么是docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker应用场景"><span class="nav-number">2.</span> <span class="nav-text">docker应用场景</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么要用docker？"><span class="nav-number"></span> <span class="nav-text">为什么要用docker？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker与虚拟机的区别"><span class="nav-number"></span> <span class="nav-text">docker与虚拟机的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number"></span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker-VS-传统虚拟机"><span class="nav-number"></span> <span class="nav-text">docker  VS 传统虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环境配置的难题"><span class="nav-number"></span> <span class="nav-text">环境配置的难题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解决方案一-虚拟机"><span class="nav-number"></span> <span class="nav-text">解决方案一 虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解决方案二-Linux容器"><span class="nav-number"></span> <span class="nav-text">解决方案二  Linux容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker容器的优势"><span class="nav-number"></span> <span class="nav-text">docker容器的优势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#工作中的虚拟化和容器"><span class="nav-number"></span> <span class="nav-text">工作中的虚拟化和容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker三大概念"><span class="nav-number"></span> <span class="nav-text">docker三大概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker-Registry"><span class="nav-number"></span> <span class="nav-text">docker Registry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CentOS安装docker"><span class="nav-number"></span> <span class="nav-text">CentOS安装docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker镜像加速器"><span class="nav-number"></span> <span class="nav-text">Docker镜像加速器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker基础命令注释"><span class="nav-number"></span> <span class="nav-text">docker基础命令注释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用docker镜像"><span class="nav-number"></span> <span class="nav-text">使用docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#搜索docker镜像"><span class="nav-number"></span> <span class="nav-text">搜索docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取docker镜像"><span class="nav-number"></span> <span class="nav-text">获取docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查看docker镜像"><span class="nav-number"></span> <span class="nav-text">查看docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除Docker镜像"><span class="nav-number"></span> <span class="nav-text">删除Docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#导出docker镜像"><span class="nav-number"></span> <span class="nav-text">导出docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#导入docker镜像"><span class="nav-number"></span> <span class="nav-text">导入docker镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#启动docker容器的方式"><span class="nav-number"></span> <span class="nav-text">启动docker容器的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新建容器并且启动"><span class="nav-number"></span> <span class="nav-text">新建容器并且启动</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker与”hello-docker”"><span class="nav-number"></span> <span class="nav-text">docker与”hello docker”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行一个ubuntu容器"><span class="nav-number"></span> <span class="nav-text">运行一个ubuntu容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行这个乌班图容器！"><span class="nav-number"></span> <span class="nav-text">运行这个乌班图容器！</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker与CentOS"><span class="nav-number"></span> <span class="nav-text">Docker与CentOS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后台模式启动docker"><span class="nav-number"></span> <span class="nav-text">后台模式启动docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进入容器"><span class="nav-number"></span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提交创建自定义的镜像-docker-container-commit"><span class="nav-number"></span> <span class="nav-text">提交创建自定义的镜像(docker container commit)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#外部访问容器"><span class="nav-number"></span> <span class="nav-text">外部访问容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看指定容器的端口映射"><span class="nav-number">1.</span> <span class="nav-text">查看指定容器的端口映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#利用dockerfile定制镜像"><span class="nav-number"></span> <span class="nav-text">利用dockerfile定制镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发布docker-image到仓库"><span class="nav-number"></span> <span class="nav-text">发布docker image到仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有仓库"><span class="nav-number">1.</span> <span class="nav-text">私有仓库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#打包flask程序与dockerfile"><span class="nav-number"></span> <span class="nav-text">打包flask程序与dockerfile</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yaosir0317</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
